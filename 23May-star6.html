<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nomads Accounting - UK Tax & Crypto Tax Experts</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/phosphor-icons/1.4.2/css/phosphor.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Georgia&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Inter', sans-serif;
      font-weight: 300;
      color: #ffffff;
    }

    body {
      background: #010102; 
      overflow-x: hidden;
    }

    /* Navigation */
    nav {
      position: sticky;
      top: 0;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000; 
    }

    nav ul {
      display: flex;
      list-style: none;
      gap: 2rem;
    }

    nav ul li a {
      text-decoration: none;
      font-size: 1rem;
      letter-spacing: -0.05em;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    nav ul li a:hover {
      opacity: 1;
    }

    nav .logo a {
        color: #ffffff; /* Assuming white is the desired color like other text */
        text-decoration: none;
        opacity: 1; /* Ensure it's fully opaque, or adjust if needed */
    }

    .burger {
      display: none;
      cursor: pointer;
      font-size: 1.5rem;
    }

    .mobile-menu {
      display: none;
    }

    .btn {
      padding: 0.8rem 1.5rem;
      background: #1a1a1a;
      border-radius: 12px;
      box-shadow: inset 4px 4px 8px rgba(0, 0, 0, 0.3), inset -4px -4px 8px rgba(255, 255, 255, 0.1);
      text-decoration: none;
      font-size: 1rem;
      opacity: 0.7;
      transition: all 0.3s;
      display: inline-block; /* Ensure button respects margins */
      margin-top: 1rem; /* Add some space if needed */
    }

    .btn:hover {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      opacity: 1;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 2rem;
      margin: 1rem;
      transition: all 0.5s;
      display: flex; 
      flex-direction: column;
      justify-content: space-between; 
    }
    
    .card ul {
      list-style: none; /* Remove default bullet points */
      padding-left: 0; /* Remove default padding */
      margin-bottom: 1.5rem; /* Space before button */
      text-align: left; /* Align list items to the left */
    }

    .card ul li {
      margin-bottom: 0.5rem; /* Space between list items */
      display: flex; /* Align icon and text */
      align-items: flex-start; /* Align items to the start of the flex line */
    }

    .card ul li::before {
      content: '✓'; /* Checkmark icon */
      color: #00ccff; /* Icon color */
      margin-right: 0.5rem; /* Space between icon and text */
      font-weight: bold;
    }


    .animate-in {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeInUp 0.6s forwards;
    }

    @keyframes fadeInUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .scroll-animate {
      opacity: 0;
      filter: blur(5px);
      transform: translateY(50px);
      transition: all 0.8s;
    }

    .scroll-animate.visible {
      opacity: 1;
      filter: blur(0);
      transform: translateY(0);
    }

    .hero {
      text-align: center;
      padding: 4rem 2rem; 
      min-height: 500px; 
      background: #010102; 
      position: relative; 
      overflow: hidden; 
      display: flex; 
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .hero h1,
    .hero p,
    .hero .btn {
      position: relative; 
      z-index: 2; 
      text-shadow: 0px 0px 10px rgba(0,0,0,0.6); 
    }
    
    .hero h1 {
      font-size: 3.5rem;
      letter-spacing: -0.08em;
      margin-bottom: 1rem;
    }

    .hero p {
      font-size: 1.2rem;
      opacity: 0.85; 
      margin-bottom: 2rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .hero-canvas {
      width: 100%;  
      height: 100%; 
      position: absolute; 
      top: 0;
      left: 0;
      z-index: 0;     
    }

    .featured-in { background-color: #101013; padding: 2rem; text-align: center;}
    .testimonials { padding: 4rem 2rem; text-align: center; background-color: #010102; }
    .how-it-works { background-color: #101013; padding: 4rem 2rem; text-align: center;}
    .features { padding: 4rem 2rem; text-align: center; background-color: #010102; }
    .mission { background-color: #1a1a1a; padding: 4rem 2rem; text-align: center;}
    .pricing { padding: 4rem 2rem; text-align: center; background-color: #010102; }
    .faq { background-color: #101013; padding: 4rem 2rem; text-align: center;}
    footer { background-color: #1a1a1a; padding: 2rem; text-align: center; opacity: 0.6;}

    .featured-in img {
      height: 40px;
      margin: 0 1rem;
      opacity: 0.7;
      onerror: "this.style.display='none'";
    }
    .carousel {
      display: flex;
      overflow-x: auto;
      gap: 2rem;
      padding-bottom: 1rem; 
    }
    .carousel .card {
      min-width: 300px;
      flex-shrink: 0; 
    }
   .how-it-works .cards, .features .cards, .pricing .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 2rem;
    }
    .features .cards { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));}

    .recommended {
      position: relative;
    }
    .recommended::after {
      content: 'Recommended';
      position: absolute;
      top: -1rem;
      right: 1rem;
      background: #4a90e2;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.9rem;
    }
    .faq details {
      margin: 1rem 0;
      text-align: left;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      background: rgba(255, 255, 255, 0.03);
      padding: 1rem;
      border-radius: 8px;
    }
    .faq summary {
        cursor: pointer;
        font-weight: 500;
    }

    @media (max-width: 768px) {
      nav ul { display: none; }
      .burger { display: block; }
      .mobile-menu.active { display: block; position: fixed; top: 0; right: 0; width: 80%; height: 100%; background: rgba(10, 10, 10, 0.9); backdrop-filter: blur(10px); padding: 4rem 2rem; transform: translateX(0); transition: transform 0.3s ease-in-out; z-index: 999; }
      .mobile-menu { transform: translateX(100%); }
      .mobile-menu ul { flex-direction: column; gap: 1rem; }
      .hero h1 { font-size: 2.5rem; }
      .hero p { font-size: 1rem; }
      .hero { min-height: 400px; padding: 3rem 1rem; }
      .carousel .card { min-width: 280px; }
      .how-it-works .cards, .features .cards, .pricing .cards { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <nav>
    <div class="logo"><a href="#hero">Nomads Accounting</a></div>
    <ul>
      <li><a href="#hero">Home</a></li>
      <li><a href="#featured-in">Featured</a></li>
      <li><a href="#testimonials">Testimonials</a></li>
      <li><a href="#how-it-works">How It Works</a></li>
      <li><a href="#features">Features</a></li>
      <li><a href="#mission">Mission</a></li>
      <li><a href="#pricing">Pricing</a></li>
      <li><a href="#faq">FAQ</a></li>
    </ul>
    <div class="burger" id="mobileMenuButton" role="button" aria-label="Open menu" aria-expanded="false" aria-controls="mobileNavMenu"><i class="ph-list"></i></div>
    <div class="mobile-menu" id="mobileNavMenu">
      <ul>
        <li><a href="#hero">Home</a></li>
        <li><a href="#featured-in">Featured</a></li>
        <li><a href="#testimonials">Testimonials</a></li>
        <li><a href="#how-it-works">How It Works</a></li>
        <li><a href="#features">Features</a></li>
        <li><a href="#mission">Mission</a></li>
        <li><a href="#pricing">Pricing</a></li>
        <li><a href="#faq">FAQ</a></li>
      </ul>
    </div>
  </nav>
  
  <section id="hero" class="hero animate-in">
    <div id="hologram" class="hero-canvas"></div> 
    <h1>Expert UK Tax & Crypto Tax Solutions</h1>
    <p>Simplify your tax obligations with Nomads Accounting, tailored for UK residents and crypto investors.</p>
    <a href="#pricing" class="btn">Get Started</a>
  </section>
  
  <section id="featured-in" class="featured-in scroll-animate">
    <h2>Featured In</h2>
    <div>
      <!-- <img src="https://placehold.co/150x40/333333/FFFFFF?text=Tax+Journal" alt="Tax Journal"> -->
      <!-- <img src="https://placehold.co/150x40/333333/FFFFFF?text=Accountancy+Age" alt="Accountancy Age"> -->
      <!-- <img src="https://placehold.co/150x40/333333/FFFFFF?text=Crypto+News" alt="Crypto News"> -->
      <!-- Placeholder for actual client logos -->
    </div>
  </section>

  <section id="testimonials" class="testimonials scroll-animate">
    <h2>Client Success Stories</h2>
    <div class="carousel">
      <div class="card">
        <p>"Nomads Accounting saved me hours on my crypto tax calculations!"</p>
        <p><strong>Result:</strong> Reduced tax liability by £5,000</p>
        <p>- Jane D.</p>
      </div>
      <div class="card">
        <p>"Their UK tax expertise is unmatched, especially for self-employed nomads."</p>
        <p><strong>Result:</strong> Maximized deductions, saved £3,200</p>
        <p>- Mark S.</p>
      </div>
      <div class="card">
        <p>"Stress-free crypto tax reporting, highly recommend!"</p>
        <p><strong>Result:</strong> Compliant filing, saved £4,800</p>
        <p>- Sarah L.</p>
      </div>
       <div class="card">
        <p>"Navigating DeFi taxes was a nightmare until I found them."</p>
        <p><strong>Result:</strong> Clear reporting, peace of mind!</p>
        <p>- Alex P.</p>
      </div>
    </div>
  </section>

  <section id="how-it-works" class="how-it-works scroll-animate">
    <h2>How It Works</h2>
    <div class="cards">
      <div class="card">
        <i class="ph-wallet-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>Connect Your Accounts</h3>
        <p>Link your crypto wallets and financial accounts securely.</p>
      </div>
      <div class="card">
        <i class="ph-chart-line-up-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>Expert Analysis</h3>
        <p>Our specialists review your transactions and optimize for UK/crypto tax.</p>
      </div>
      <div class="card">
        <i class="ph-file-text-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>File with Confidence</h3>
        <p>We handle your tax filings, ensuring compliance and savings.</p>
      </div>
    </div>
  </section>

  <section id="features" class="features scroll-animate">
    <h2>Our Services</h2>
    <div class="cards">
      <div class="card">
        <i class="ph-coins-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>Crypto Tax Reporting</h3>
        <p>Accurate calculations for UK crypto tax obligations, including DeFi & NFTs.</p>
      </div>
      <div class="card">
        <i class="ph-briefcase-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>Self-Assessment Filing</h3>
        <p>Streamlined UK self-assessment tax services for individuals and businesses.</p>
      </div>
      <div class="card">
        <i class="ph-shield-check-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>HMRC Compliance</h3>
        <p>Ensure full compliance with the latest UK tax regulations and HMRC guidelines.</p>
      </div>
      <div class="card">
        <i class="ph-phone-call-light ph-2x" style="font-size: 2.5rem; margin-bottom: 0.5rem; color: #00ccff;"></i>
        <h3>Consultation Call</h3>
        <p>30 mins - $99</p>
        <a href="#" class="btn" style="margin-top: auto;">Book Now</a> </div>
    </div>
  </section>

  <section id="mission" class="mission scroll-animate">
    <h2>Our Mission</h2>
    <p>At Nomads Accounting, we empower UK residents and crypto investors to navigate the complexities of tax compliance with ease. Our mission is to provide transparent, expert-led accounting services that maximize savings and ensure peace of mind in the evolving digital economy.</p>
  </section>

  <section id="pricing" class="pricing scroll-animate">
    <h2>Pricing Plans</h2>
    <div class="cards">
      <div class="card">
        <h3>Platinum</h3>
        <p style="font-size: 2rem; font-weight: 500; margin-bottom: 0.5rem;">$399</p>
        <p style="font-size: 0.9rem; opacity: 0.7; margin-bottom: 1.5rem;">Per month</p>
        <ul>
          <li>Company accounts and tax returns produced and submitted to HMRC and Companies House</li>
          <li>VAT returns (where applicable)</li>
          <li>Payroll for employees</li>
          <li>Management reports</li>
          <li>Ongoing advice</li>
          <li>Dealing with HMRC letters</li>
          <li>Tax advice</li>
          <li>Tailored to support your business needs</li>
          <li>30-min Private Banker vid calls/month (inclusive of Financial Planning & Analysis and Capital Strategy consulting)</li>
          <li>Virtual CFO - Access your own dedicated & experienced chartered accountant for advice (via email/text)</li>
        </ul>
        <a href="#" class="btn" style="margin-top: auto;">Choose Plan</a>
      </div>
      <div class="card recommended">
        <h3>Titanium</h3>
        <p style="font-size: 2rem; font-weight: 500; margin-bottom: 0.5rem;">$599</p>
        <p style="font-size: 0.9rem; opacity: 0.7; margin-bottom: 1.5rem;">Per month</p>
        <ul>
          <li>Company accounts and tax returns produced and submitted to HMRC and Companies House</li>
          <li>VAT returns (where applicable)</li>
          <li>Payroll for employees</li>
          <li>Management reports</li>
          <li>Ongoing advice</li>
          <li>Dealing with HMRC letters</li>
          <li>Tax advice</li>
          <li>Tailored to support your business needs</li>
          <li>30-min Private Banker vid calls/month (inclusive of Financial Planning & Analysis and Capital Strategy consulting)</li>
          <li>Virtual CFO - Access your own dedicated & experienced chartered accountant for advice (via email/text)</li>
        </ul>
        <a href="#" class="btn" style="margin-top: auto;">Choose Plan</a>
      </div>
      <div class="card">
        <h3>Diamond</h3>
        <p style="font-size: 2rem; font-weight: 500; margin-bottom: 0.5rem;">$1999</p>
        <p style="font-size: 0.9rem; opacity: 0.7; margin-bottom: 1.5rem;">Per month</p>
        <ul>
          <li>Company accounts and tax returns produced and submitted to HMRC and Companies House</li>
          <li>VAT returns (where applicable)</li>
          <li>Payroll for employees</li>
          <li>Management reports</li>
          <li>Ongoing advice</li>
          <li>Dealing with HMRC letters</li>
          <li>Tax advice</li>
          <li>Tailored to support your business needs</li>
          <li>1hr Private Banker vid calls/weeks (inclusive of Financial Planning & Analysis and Capital Strategy consulting)</li>
          <li>Virtual CFO - Access your own dedicated & experienced chartered accountant for advice (via email/text) Tailored to support your business needs</li>
        </ul>
        <a href="#" class="btn" style="margin-top: auto;">Contact Us</a>
      </div>
    </div>
  </section>

  <section id="faq" class="faq scroll-animate">
    <h2>Frequently Asked Questions</h2>
    <details>
      <summary>How do you calculate crypto taxes for the UK?</summary>
      <p>We follow HMRC guidelines, calculating Capital Gains Tax (CGT) on disposals of cryptoassets. This includes sales for fiat, exchanges for other crypto, and using crypto to pay for goods/services. We also account for income tax on activities like mining or staking where applicable.</p>
    </details>
    <details>
      <summary>Do you support DeFi and NFT tax calculations?</summary>
      <p>Yes, our Pro Crypto and Business plans include support for complex DeFi transactions (liquidity pools, lending, yield farming) and NFT taxation, which can be particularly nuanced.</p>
    </details>
    <details>
      <summary>Can you help with late tax filings or amendments?</summary>
      <p>Absolutely. We can assist with preparing and submitting late tax returns and help amend previous filings if errors are discovered. We can also advise on potential penalties and how to communicate with HMRC.</p>
    </details>
    <details>
      <summary>Is my financial and crypto data secure with you?</summary>
      <p>Data security is paramount. We use industry-standard encryption and secure protocols to protect your financial and personal information. We only require read-access to your exchange/wallet data where possible.</p>
    </details>
  </section>

  <footer>
    <p>© 2025 Nomads Accounting. All rights reserved. UK Registered Company 12345678.</p>
  </footer>

  <script>
    // Mobile menu toggle
    const burgerButton = document.getElementById('mobileMenuButton'); // Use ID selector
    const mobileMenu = document.getElementById('mobileNavMenu'); // Use ID selector
    const navLinks = document.querySelectorAll('.mobile-menu a'); 

    burgerButton.addEventListener('click', () => {
      mobileMenu.classList.toggle('active');
      const icon = burgerButton.querySelector('i');
      if (mobileMenu.classList.contains('active')) {
        icon.classList.remove('ph-list');
        icon.classList.add('ph-x');
        burgerButton.setAttribute('aria-expanded', 'true');
        burgerButton.setAttribute('aria-label', 'Close menu');
      } else {
        icon.classList.remove('ph-x');
        icon.classList.add('ph-list');
        burgerButton.setAttribute('aria-expanded', 'false');
        burgerButton.setAttribute('aria-label', 'Open menu');
      }
    });

    navLinks.forEach(link => {
      link.addEventListener('click', () => {
        if (mobileMenu.classList.contains('active')) {
          mobileMenu.classList.remove('active');
          const icon = burgerButton.querySelector('i'); // Ensure icon updates correctly
          icon.classList.remove('ph-x');
          icon.classList.add('ph-list');
          burgerButton.setAttribute('aria-expanded', 'false');
          burgerButton.setAttribute('aria-label', 'Open menu');
        }
      });
    });


    // Scroll animations
    const scrollElements = document.querySelectorAll('.scroll-animate');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 }); 

    scrollElements.forEach(el => observer.observe(el));

    // Three.js Hologram
    const hologramContainer = document.getElementById('hologram'); 
    
    let scene, camera, renderer, coin, rim, mainCoinMaterial, miniCoinsGroup, starParticles; 
    const miniCoins = []; 
    const currencySymbols = ['$', '€', '¥', '£', '₿', '₹', '₽']; 
    const miniCoinTextures = [];
    let starVelocities, starBaseSizes; 
    let mainCoinRadius; 
    let starCount; 
    let starSpreadX, starSpreadY, starSpreadZ; // Declarations remain global


    // Function to create a texture with a currency symbol
    function createCurrencyTexture(symbol, bgColor = 'rgba(255, 215, 0, 0.8)', textColor = 'rgba(0,0,0,0.8)') {
        const canvas = document.createElement('canvas');
        canvas.width = 128; 
        canvas.height = 128;
        const context = canvas.getContext('2d');
        
        context.fillStyle = bgColor;
        context.beginPath();
        context.arc(64, 64, 60, 0, Math.PI * 2);
        context.fill();
        
        context.font = 'bold 70px Arial'; 
        context.fillStyle = textColor;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(symbol, 64, 64);
        
        return new THREE.CanvasTexture(canvas);
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(75, hologramContainer.clientWidth / hologramContainer.clientHeight, 0.1, 1000); 
        
        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); 
        renderer.setSize(hologramContainer.clientWidth, hologramContainer.clientHeight);
        renderer.outputEncoding = THREE.sRGBEncoding; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.35; 
        hologramContainer.appendChild(renderer.domElement); 

        // ---- START MOVED/MODIFIED SECTION ----
        // Ensure hologramContainer is valid and has dimensions before calculating spread
        const heroWidth = hologramContainer.clientWidth || window.innerWidth; 
        const heroHeight = hologramContainer.clientHeight || window.innerHeight;
        
        starSpreadX = Math.max(heroWidth / 30, 20); 
        starSpreadY = Math.max(heroHeight / 30, 15);
        starSpreadZ = Math.max(Math.min(starSpreadX, starSpreadY) * 0.6, 10);
        // ---- END MOVED/MODIFIED SECTION ----

        currencySymbols.forEach(symbol => {
            const bgColors = [ 
                'rgba(255, 223, 0, 0.75)',   
                'rgba(192, 192, 192, 0.75)', 
                'rgba(205, 127, 50, 0.75)', 
                'rgba(100, 149, 237, 0.75)',
                'rgba(255, 105, 180, 0.75)',
                'rgba(60, 179, 113, 0.75)', 
                'rgba(218, 112, 214, 0.75)' 
            ]; 
            const bgColor = bgColors[miniCoinTextures.length % bgColors.length];
            const textColors = ['#222222', '#FFFFFF', '#111111', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF'];
            const textColor = textColors[miniCoinTextures.length % textColors.length];
            miniCoinTextures.push(createCurrencyTexture(symbol, bgColor, textColor));
        });

        mainCoinRadius = 2.8; 
        const mainCoinThickness = 0.28; 
        const coinGeometry = new THREE.CylinderGeometry(mainCoinRadius, mainCoinRadius, mainCoinThickness, 128); 

        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 256; 
        textureCanvas.height = 256;
        const context = textureCanvas.getContext('2d');
        context.clearRect(0, 0, textureCanvas.width, textureCanvas.height); 
        let fontSizeForNA = Math.floor(textureCanvas.height * 0.6); 
        context.font = `bold ${fontSizeForNA}px Georgia, serif`; 
        context.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText('NA', textureCanvas.width / 2, textureCanvas.height / 2); 
        const faceTexture = new THREE.CanvasTexture(textureCanvas);
        faceTexture.needsUpdate = true; 

        const vertexShader = `
          varying vec3 vNormal;
          varying vec3 vPosition; 
          varying vec2 vUv;
          attribute vec3 morphTarget0; 
          uniform float morphTargetInfluences[1];
          void main() {
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            vec3 morphedPosition = position;
            if (morphTargetInfluences[0] > 0.0) {
                 morphedPosition += morphTarget0 * morphTargetInfluences[0];
            }
            vec4 mvPosition = modelViewMatrix * vec4(morphedPosition, 1.0);
            vPosition = mvPosition.xyz; 
            gl_Position = projectionMatrix * mvPosition;
          }
        `;

        const fragmentShader = `
          uniform float time;
          uniform sampler2D uFaceTexture; 
          varying vec3 vNormal;
          varying vec3 vPosition; 
          varying vec2 vUv;
          uniform vec3 cameraPos; 

          float rand(vec2 n) { 
            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
          }

          vec3 luxuriousDarkRainbow(float t) {
            vec3 c1 = vec3(0.3, 0.1, 0.5); 
            vec3 c2 = vec3(0.1, 0.3, 0.6); 
            vec3 c3 = vec3(0.5, 0.3, 0.1); 
            vec3 c4 = vec3(0.1, 0.4, 0.3); 
            
            float mt = mod(t * 0.6, 1.0); 
            vec3 color;
            if (mt < 0.25) color = mix(c1, c2, mt / 0.25);
            else if (mt < 0.5) color = mix(c2, c3, (mt - 0.25) / 0.25);
            else if (mt < 0.75) color = mix(c3, c4, (mt - 0.5) / 0.25);
            else color = mix(c4, c1, (mt - 0.75) / 0.25);
            return color * (sin(t * 3.14159 * 1.0) * 0.2 + 0.6); 
          }

          void main() {
            vec3 normal = normalize(vNormal);
            vec3 viewDir = normalize(cameraPos - vPosition); 
            float fresnelTerm = 1.0 - dot(normal, viewDir);
            fresnelTerm = pow(fresnelTerm, 3.0); 
            fresnelTerm = clamp(fresnelTerm * 1.6, 0.0, 1.0); 
            
            vec3 reflectedDir = reflect(-viewDir, normal);
            float holoFactor = (sin((reflectedDir.x - reflectedDir.y * 0.6 + reflectedDir.z * 0.3) * 9.0 + time * 1.5) * 0.5 + 0.5);
            vec3 rainbowColor = luxuriousDarkRainbow(holoFactor + vUv.y * 0.35 + vUv.x * 0.1); 
            
            float dispersionStrength = 0.02 * fresnelTerm; 
            vec3 dispersionColor = vec3(
              dot(normal, vec3(0.8,0.1,0.1)) * 0.4 + 0.6, 
              dot(normal, vec3(0.1,0.8,0.1)) * 0.4 + 0.6, 
              dot(normal, vec3(0.1,0.1,0.8)) * 0.4 + 0.6  
            );
            dispersionColor = mix(vec3(0.9), dispersionColor, dispersionStrength); 
            
            float alpha = mix(0.70, 0.98, fresnelTerm); 
            
            vec4 texColor = texture2D(uFaceTexture, vUv);
            vec3 finalColor = vec3(0.0); 

            if (vUv.x > 0.01 && vUv.x < 0.99 && vUv.y > 0.01 && vUv.y < 0.99) { 
                finalColor = rainbowColor * dispersionColor * 0.65 + texColor.rgb * texColor.a * 0.65; 
                finalColor += vec3(0.7, 0.7, 0.9) * fresnelTerm * 0.45; 
            } else { 
                finalColor = rainbowColor * dispersionColor * 0.40 + vec3(0.6,0.6,0.8) * fresnelTerm;
                alpha = mix(0.85, 1.0, fresnelTerm);
            }
            finalColor += vec3(0.1, 0.2, 0.4) * 0.1; 
            gl_FragColor = vec4(finalColor, alpha);
          }
        `;
        
        mainCoinMaterial = new THREE.ShaderMaterial({
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          uniforms: {
            time: { value: 0.0 },
            uFaceTexture: { value: faceTexture }, 
            cameraPos: { value: camera.position } 
          },
          transparent: true,
          side: THREE.DoubleSide,
          depthWrite: false 
        });

        coin = new THREE.Mesh(coinGeometry, mainCoinMaterial);
        scene.add(coin);
        
        const morphPositions = coinGeometry.attributes.position.clone();
        for (let i = 0; i < morphPositions.count; i++) {
            morphPositions.array[i * 3 + 2] += Math.sin(morphPositions.array[i*3] * 2.0 + morphPositions.array[i*3+1]*1.0) * 0.05;
        }
        coinGeometry.morphAttributes.position = [morphPositions];
        coin.morphTargetInfluences = [0.1]; 

        const rimRadius = mainCoinRadius; 
        const rimThickness = 0.06; 
        const rimGeometry = new THREE.TorusGeometry(rimRadius, rimThickness, 16, 128); 
        const rimMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x70a0d0, metalness: 0.3, roughness: 0.15, 
            transmission: 0.4, ior: 1.55, thickness: 0.1,
            emissive: 0x4070a0, emissiveIntensity: 0.5, 
            transparent: true, opacity: 0.88, side: THREE.DoubleSide
        });
        rim = new THREE.Mesh(rimGeometry, rimMaterial);
        rim.rotation.x = Math.PI / 2; 
        coin.add(rim); 

        miniCoinsGroup = new THREE.Group();
        scene.add(miniCoinsGroup); 

        const numMiniCoins = currencySymbols.length;
        const miniCoinRadius = 0.3; 
        const miniCoinThickness = 0.04; 
        const orbitRadius = mainCoinRadius + 1.8; 

        const miniCoinGeometry = new THREE.CylinderGeometry(miniCoinRadius, miniCoinRadius, miniCoinThickness, 32); 
        
        for (let i = 0; i < numMiniCoins; i++) {
            const miniMaterial = new THREE.MeshPhysicalMaterial({
                map: miniCoinTextures[i % miniCoinTextures.length], 
                metalness: 0.7, roughness: 0.2,  
                emissive: 0x444400, emissiveIntensity: 0.5, 
                transparent: true, opacity: 0.95, side: THREE.DoubleSide
            });
            const miniCoin = new THREE.Mesh(miniCoinGeometry, miniMaterial);
            const angle = (i / numMiniCoins) * Math.PI * 2;
            miniCoin.position.x = Math.cos(angle) * orbitRadius;
            miniCoin.position.z = Math.sin(angle) * orbitRadius;
            miniCoin.position.y = (i % 2 === 0 ? 1 : -1) * 0.25 + (Math.random() * 0.2 - 0.1); 
            
            miniCoin.rotation.x = Math.random() * Math.PI;
            miniCoin.rotation.y = Math.random() * Math.PI;
            miniCoinsGroup.add(miniCoin);
            miniCoins.push(miniCoin);
        }

        starCount = 3500; 
        // const heroWidth = hologramContainer.clientWidth || window.innerWidth; // Moved up
        // const heroHeight = hologramContainer.clientHeight || window.innerHeight; // Moved up
        // starSpreadX = Math.max(heroWidth / 30, 20); // Moved up
        // starSpreadY = Math.max(heroHeight / 30, 15); // Moved up
        // starSpreadZ = Math.max(Math.min(starSpreadX, starSpreadY) * 0.6, 10); // Moved up


        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        starBaseSizes = new Float32Array(starCount); 
        starVelocities = new Float32Array(starCount * 3);


        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3 + 0] = (Math.random() - 0.5) * starSpreadX; 
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * starSpreadY;
            starPositions[i * 3 + 2] = (Math.random() * -starSpreadZ) - mainCoinRadius * 1.5; 

            const color = new THREE.Color();
            color.setHSL(Math.random() * 0.1 + 0.55, 0.9, Math.random() * 0.4 + 0.55); 
            starColors[i*3+0] = color.r;
            starColors[i*3+1] = color.g;
            starColors[i*3+2] = color.b;
            
            starBaseSizes[i] = Math.random() * 0.045 + 0.01; 

            starVelocities[i * 3 + 0] = (Math.random() - 0.5) * 0.0005; 
            starVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.0005;
            starVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.0005;
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starBaseSizes, 1)); 


        const starMaterial = new THREE.PointsMaterial({
            size: 0.06, 
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true, 
            sizeAttenuation: true 
        });
        starParticles = new THREE.Points(starGeometry, starMaterial);
        scene.add(starParticles);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8); 
        directionalLight1.position.set(5, 7, 5); 
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xaaaaff, 0.5); 
        directionalLight2.position.set(-5, -3, -5);
        scene.add(directionalLight2);

        const pointLight1 = new THREE.PointLight(0xffaaff, 0.7, 20); 
        pointLight1.position.set(0, 4, 4);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xaafeff, 0.7, 20); 
        pointLight2.position.set(0, -4, 4);
        scene.add(pointLight2);

        camera.position.set(0, 0.8 , 7.5); 
        camera.lookAt(coin.position); 
    }


    function animate() {
      if (renderer && scene && camera && coin && mainCoinMaterial && starParticles) { 
        requestAnimationFrame(animate);
        
        const elapsedTime = Date.now() * 0.001; 

        const speedMultiplier = 1; 
        coin.rotation.x += 0.0015 * speedMultiplier; 
        coin.rotation.y += 0.0025 * speedMultiplier; 
        coin.rotation.z += 0.0010 * speedMultiplier; 
        
        if(mainCoinMaterial.uniforms) { 
            mainCoinMaterial.uniforms.time.value = elapsedTime * 0.3 * speedMultiplier; 
            mainCoinMaterial.uniforms.cameraPos.value.copy(camera.position);
        }
        
        if(coin.morphTargetInfluences) { 
            coin.morphTargetInfluences[0] = (Math.sin(elapsedTime * 0.3 * speedMultiplier) + 1.0) / 2.0 * 0.1; 
        }

        if (miniCoinsGroup) {
            miniCoinsGroup.rotation.y += 0.003 * speedMultiplier; 
            miniCoinsGroup.rotation.x = Math.sin(elapsedTime * 0.15 * speedMultiplier) * 0.1; 

            miniCoins.forEach((mc, index) => {
                mc.rotation.y += (0.015 + index * 0.002) * speedMultiplier; 
                mc.rotation.x += (0.010 + index * 0.001) * speedMultiplier;
                mc.position.y = Math.sin(elapsedTime * (0.8 + index * 0.05) * speedMultiplier + index) * 0.3 - 0.05; 
                
                if (mc.material.emissiveIntensity) {
                    mc.material.emissiveIntensity = 0.5 + Math.sin(elapsedTime * 4 * speedMultiplier + index * 2) * 0.4;
                }
            });
        }

        // Animate Stars (No global spin, just drift and sparkle)
        if (starParticles) {
            const positions = starParticles.geometry.attributes.position.array;
            const sizes = starParticles.geometry.attributes.size.array; 
            
            // Use the globally accessible starSpreadX, Y, Z for boundary checks
            const currentStarSpreadX = starSpreadX * 1.15; 
            const currentStarSpreadY = starSpreadY * 1.15;
            const currentStarSpreadZ = starSpreadZ * 1.2;


            for (let i = 0; i < starCount; i++) { // starCount is now accessible
                positions[i * 3 + 0] += starVelocities[i * 3 + 0] * speedMultiplier * 0.2; 
                positions[i * 3 + 1] += starVelocities[i * 3 + 1] * speedMultiplier * 0.2;
                positions[i * 3 + 2] += starVelocities[i * 3 + 2] * speedMultiplier * 0.2;

                if (Math.abs(positions[i * 3 + 0]) > currentStarSpreadX / 2) positions[i * 3 + 0] = -Math.sign(positions[i * 3 + 0]) * currentStarSpreadX / 2 * Math.random();
                if (Math.abs(positions[i * 3 + 1]) > currentStarSpreadY / 2) positions[i * 3 + 1] = -Math.sign(positions[i * 3 + 1]) * currentStarSpreadY / 2 * Math.random();
                
                // Adjust Z wrapping for contained hero section stars
                if (positions[i * 3 + 2] > mainCoinRadius * 0.5) { 
                     positions[i * 3 + 2] = -starSpreadZ - Math.random()*0.5; 
                } else if (positions[i * 3 + 2] < -starSpreadZ * 1.1 - mainCoinRadius * 1.5) { // Adjusted lower bound
                     positions[i * 3 + 2] = -mainCoinRadius * 1.5 - Math.random()*0.5; 
                }
                
                sizes[i] = starBaseSizes[i] * (0.6 + Math.abs(Math.sin(elapsedTime * (3.0 + i * 0.25) * speedMultiplier)) * 0.4) ;
            }
            starParticles.geometry.attributes.position.needsUpdate = true;
            starParticles.geometry.attributes.size.needsUpdate = true;
        }

        renderer.render(scene, camera);
      }
    }
    
    function onWindowResize() {
        // MODIFIED: Update camera and renderer for hologramContainer (hero section) resize
        if (camera && renderer && hologramContainer) {
            const width = hologramContainer.clientWidth;
            const height = hologramContainer.clientHeight;
            
            if (width > 0 && height > 0) { 
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);

                // Re-calculate star spread factors on resize if they depend on canvas size
                starSpreadX = Math.max(width / 30, 25); 
                starSpreadY = Math.max(height / 30, 20);
                starSpreadZ = Math.max(Math.min(starSpreadX, starSpreadY) * 0.8, 15);
            }
        }
    }

    window.addEventListener('load', () => {
        if (hologramContainer) { 
            initThreeJS();
            onWindowResize(); 
            animate(); 
            window.addEventListener('resize', onWindowResize, false);
        } else {
            console.error("Hero canvas container 'hologram' not found.");
        }
    });

  </script>
</body>
</html>